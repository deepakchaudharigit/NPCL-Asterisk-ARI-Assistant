"""
Enhanced Voice Assistant with comprehensive multi-language support
Integrates multilingual TTS, STT, and AI processing for NPCL customer service
"""

import logging
import time
from typing import Optional, Dict, Any, Callable
from enum import Enum

from ..i18n.language_manager import LanguageManager, SupportedLanguage
from ..audio.multilingual_tts import MultilingualTTS
from ..audio.multilingual_stt import MultilingualSTT
from ..ai.gemini_client import GeminiClient
from ..utils.logger import setup_logger

import sys
from pathlib import Path

# Add project root to path
project_root = Path(__file__).parent.parent.parent.parent
sys.path.insert(0, str(project_root))

from config.settings import get_settings

logger = logging.getLogger(__name__)

class AssistantState(Enum):
    """Assistant state enumeration"""
    IDLE = "idle"
    LISTENING = "listening"
    PROCESSING = "processing"
    SPEAKING = "speaking"
    LANGUAGE_SWITCHING = "language_switching"
    ERROR = "error"

class MultilingualVoiceAssistant:
    """Enhanced voice assistant with comprehensive multi-language support"""
    
    def __init__(self, 
                 initial_language: str = "en-IN",
                 on_state_change: Optional[Callable[[AssistantState], None]] = None,
                 on_language_change: Optional[Callable[[SupportedLanguage], None]] = None,
                 on_user_speech: Optional[Callable[[str, SupportedLanguage], None]] = None,
                 on_assistant_response: Optional[Callable[[str, SupportedLanguage], None]] = None):
        """
        Initialize multilingual voice assistant
        
        Args:
            initial_language: Initial language code (default: en-IN)
            on_state_change: Callback for state changes
            on_language_change: Callback for language changes
            on_user_speech: Callback for user speech events
            on_assistant_response: Callback for assistant response events
        """
        self.settings = get_settings()
        
        # Setup logging
        setup_logger()
        
        # Initialize language management
        self.language_manager = LanguageManager()
        if not self.language_manager.set_language(initial_language):
            logger.warning(f"Failed to set initial language {initial_language}, using English")
            self.language_manager.set_language("en-IN")
        
        # Initialize multilingual components
        self.tts = MultilingualTTS(self.language_manager)
        self.stt = MultilingualSTT(self.language_manager)
        self.ai_client = GeminiClient()
        
        # State management
        self.state = AssistantState.IDLE
        self.is_running = False
        self.conversation_count = 0
        self.auto_language_detection = True
        
        # Callbacks
        self.on_state_change = on_state_change
        self.on_language_change = on_language_change
        self.on_user_speech = on_user_speech
        self.on_assistant_response = on_assistant_response
        
        # Statistics
        self.stats = {
            "conversations": 0,
            "language_switches": 0,
            "successful_recognitions": 0,
            "failed_recognitions": 0,
            "ai_responses": 0,
            "ai_failures": 0,
            "start_time": None,
            "languages_used": set(),
            "total_speech_time": 0.0,
            "total_processing_time": 0.0
        }\n        \n        # Language-specific conversation contexts\n        self.conversation_contexts = {}\n        \n        logger.info(f\"Multilingual Voice Assistant initialized in {self.language_manager.current_language.english_name}\")\n    \n    def _set_state(self, new_state: AssistantState):\n        \"\"\"Set assistant state and trigger callback\"\"\"\n        if self.state != new_state:\n            old_state = self.state\n            self.state = new_state\n            logger.debug(f\"State changed: {old_state.value} -> {new_state.value}\")\n            \n            if self.on_state_change:\n                try:\n                    self.on_state_change(new_state)\n                except Exception as e:\n                    logger.error(f\"State change callback error: {e}\")\n    \n    def start(self) -> bool:\n        \"\"\"\n        Start the multilingual voice assistant\n        \n        Returns:\n            True if started successfully, False otherwise\n        \"\"\"\n        if self.is_running:\n            logger.warning(\"Assistant is already running\")\n            return True\n        \n        try:\n            logger.info(\"Starting multilingual voice assistant...\")\n            \n            # Test components\n            if not self._test_components():\n                return False\n            \n            # Speak welcome message in current language\n            self._speak_welcome_message()\n            \n            self.is_running = True\n            self.stats[\"start_time\"] = time.time()\n            self.stats[\"languages_used\"].add(self.language_manager.current_language.code)\n            self._set_state(AssistantState.IDLE)\n            \n            logger.info(f\"Multilingual voice assistant started in {self.language_manager.current_language.english_name}\")\n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to start assistant: {e}\")\n            self._set_state(AssistantState.ERROR)\n            return False\n    \n    def stop(self):\n        \"\"\"Stop the multilingual voice assistant\"\"\"\n        if not self.is_running:\n            return\n        \n        logger.info(\"Stopping multilingual voice assistant...\")\n        \n        # Speak farewell message in current language\n        self._speak_farewell_message()\n        \n        self.is_running = False\n        self._set_state(AssistantState.IDLE)\n        \n        # Cleanup\n        self.tts.cleanup_temp_files()\n        \n        # Log statistics\n        self._log_session_stats()\n        \n        logger.info(\"Multilingual voice assistant stopped\")\n    \n    def change_language(self, language_code: str) -> bool:\n        \"\"\"\n        Change the assistant's language\n        \n        Args:\n            language_code: New language code (e.g., 'hi-IN', 'bn-IN')\n            \n        Returns:\n            True if language changed successfully\n        \"\"\"\n        old_language = self.language_manager.current_language\n        \n        if self.language_manager.set_language(language_code):\n            new_language = self.language_manager.current_language\n            \n            self._set_state(AssistantState.LANGUAGE_SWITCHING)\n            \n            # Announce language change\n            change_message = self.language_manager.get_translation(\"language_changed\")\n            self.tts.speak(change_message, new_language)\n            \n            # Update statistics\n            self.stats[\"language_switches\"] += 1\n            self.stats[\"languages_used\"].add(new_language.code)\n            \n            # Trigger callback\n            if self.on_language_change:\n                try:\n                    self.on_language_change(new_language)\n                except Exception as e:\n                    logger.error(f\"Language change callback error: {e}\")\n            \n            self._set_state(AssistantState.IDLE)\n            \n            logger.info(f\"Language changed from {old_language.english_name} to {new_language.english_name}\")\n            return True\n        else:\n            logger.warning(f\"Failed to change language to {language_code}\")\n            return False\n    \n    def process_conversation_turn(self, auto_detect_language: bool = None) -> bool:\n        \"\"\"\n        Process one conversation turn with optional language detection\n        \n        Args:\n            auto_detect_language: Whether to auto-detect language (None = use default setting)\n            \n        Returns:\n            True to continue, False to stop\n        \"\"\"\n        if not self.is_running:\n            return False\n        \n        if auto_detect_language is None:\n            auto_detect_language = self.auto_language_detection\n        \n        try:\n            start_time = time.time()\n            \n            # Listen for user input\n            self._set_state(AssistantState.LISTENING)\n            \n            if auto_detect_language:\n                success, user_text, detected_language, error = self._listen_with_language_detection()\n            else:\n                success, user_text, error = self._listen_for_input()\n                detected_language = self.language_manager.current_language\n            \n            if not success:\n                self._handle_listening_error(error)\n                return True  # Continue listening\n            \n            # Check for exit commands\n            if self._is_exit_command(user_text):\n                return False  # Stop conversation\n            \n            # Check for language change commands\n            if self._is_language_change_command(user_text):\n                self._handle_language_change_command(user_text)\n                return True  # Continue conversation\n            \n            # Switch language if detected different language\n            if detected_language != self.language_manager.current_language:\n                logger.info(f\"Detected language switch to {detected_language.english_name}\")\n                self.change_language(detected_language.code)\n            \n            # Process user input\n            self._set_state(AssistantState.PROCESSING)\n            processing_start = time.time()\n            \n            response = self._process_user_input(user_text, detected_language)\n            \n            processing_time = time.time() - processing_start\n            self.stats[\"total_processing_time\"] += processing_time\n            \n            # Speak response\n            self._set_state(AssistantState.SPEAKING)\n            self._speak_response(response, detected_language)\n            \n            # Update statistics\n            self.conversation_count += 1\n            self.stats[\"conversations\"] += 1\n            total_time = time.time() - start_time\n            self.stats[\"total_speech_time\"] += total_time\n            \n            self._set_state(AssistantState.IDLE)\n            \n            return True  # Continue conversation\n            \n        except KeyboardInterrupt:\n            logger.info(\"Conversation interrupted by user\")\n            return False\n        except Exception as e:\n            logger.error(f\"Error in conversation turn: {e}\")\n            self._set_state(AssistantState.ERROR)\n            return True  # Try to continue\n    \n    def _listen_with_language_detection(self) -> tuple:\n        \"\"\"Listen for speech with automatic language detection\"\"\"\n        try:\n            # First, try to detect language\n            detected_language = self.stt.detect_language_from_speech(\n                timeout=10.0,\n                candidate_languages=self.language_manager.get_supported_languages(voice_only=True)\n            )\n            \n            if detected_language:\n                logger.info(f\"Detected language: {detected_language.english_name}\")\n                \n                # Listen again in the detected language\n                success, text, error = self.stt.listen_for_speech(\n                    language=detected_language,\n                    timeout=15.0,\n                    phrase_time_limit=15.0\n                )\n                \n                if success:\n                    self.stats[\"successful_recognitions\"] += 1\n                    \n                    # Trigger callback\n                    if self.on_user_speech:\n                        try:\n                            self.on_user_speech(text, detected_language)\n                        except Exception as e:\n                            logger.error(f\"User speech callback error: {e}\")\n                    \n                    return True, text, detected_language, \"\"\n                else:\n                    self.stats[\"failed_recognitions\"] += 1\n                    return False, \"\", detected_language, error\n            else:\n                # Fallback to current language\n                success, text, error = self._listen_for_input()\n                return success, text, self.language_manager.current_language, error\n                \n        except Exception as e:\n            error_msg = f\"Error in language detection: {e}\"\n            logger.error(error_msg)\n            return False, \"\", self.language_manager.current_language, error_msg\n    \n    def _listen_for_input(self) -> tuple:\n        \"\"\"Listen for user speech input in current language\"\"\"\n        logger.debug(f\"[Turn {self.conversation_count + 1}] Listening for speech in {self.language_manager.current_language.english_name}...\")\n        \n        success, text, error = self.stt.listen_for_speech(\n            language=self.language_manager.current_language,\n            timeout=15.0,\n            phrase_time_limit=15.0\n        )\n        \n        if success:\n            self.stats[\"successful_recognitions\"] += 1\n            logger.info(f\"User said: {text}\")\n            \n            if self.on_user_speech:\n                try:\n                    self.on_user_speech(text, self.language_manager.current_language)\n                except Exception as e:\n                    logger.error(f\"User speech callback error: {e}\")\n        else:\n            self.stats[\"failed_recognitions\"] += 1\n        \n        return success, text, error\n    \n    def _process_user_input(self, user_text: str, language: SupportedLanguage) -> str:\n        \"\"\"Process user input and generate response\"\"\"\n        logger.debug(f\"Processing user input in {language.english_name}: {user_text}\")\n        \n        try:\n            # Get language-specific system prompt\n            system_prompt = self._get_language_specific_system_prompt(language)\n            \n            # Generate response\n            response = self.ai_client.generate_response(user_text, system_prompt)\n            self.stats[\"ai_responses\"] += 1\n            \n            # Store conversation context\n            self._update_conversation_context(language, user_text, response)\n            \n            return response\n            \n        except Exception as e:\n            self.stats[\"ai_failures\"] += 1\n            logger.error(f\"Failed to process user input: {e}\")\n            \n            # Return error message in appropriate language\n            return self.language_manager.get_translation(\n                \"error_occurred\", \"common\", language\n            )\n    \n    def _speak_response(self, response: str, language: SupportedLanguage):\n        \"\"\"Speak the assistant's response\"\"\"\n        logger.info(f\"Assistant ({language.english_name}): {response}\")\n        \n        if self.on_assistant_response:\n            try:\n                self.on_assistant_response(response, language)\n            except Exception as e:\n                logger.error(f\"Assistant response callback error: {e}\")\n        \n        # Speak the response\n        if not self.tts.speak(response, language):\n            logger.warning(\"TTS failed, response shown as text only\")\n    \n    def _speak_welcome_message(self):\n        \"\"\"Speak welcome message in current language\"\"\"\n        welcome_message = self.language_manager.get_npcl_greeting()\n        self.tts.speak(welcome_message, self.language_manager.current_language)\n    \n    def _speak_farewell_message(self):\n        \"\"\"Speak farewell message in current language\"\"\"\n        farewell_message = self.language_manager.get_translation(\"goodbye\")\n        self.tts.speak(farewell_message, self.language_manager.current_language)\n    \n    def _test_components(self) -> bool:\n        \"\"\"Test all components\"\"\"\n        logger.info(\"Testing multilingual components...\")\n        \n        # Test AI connection\n        if not self.ai_client.test_connection():\n            logger.error(\"Gemini API connection test failed\")\n            return False\n        \n        # Test microphone\n        if not self.stt.is_microphone_available():\n            logger.error(\"Microphone not available\")\n            return False\n        \n        # Test TTS for current language\n        if not self.tts.test_language_voice(self.language_manager.current_language):\n            logger.warning(\"TTS test failed for current language, continuing anyway\")\n        \n        logger.info(\"Component tests completed\")\n        return True\n    \n    def _handle_listening_error(self, error: str):\n        \"\"\"Handle listening errors\"\"\"\n        if \"timeout\" in error.lower():\n            logger.debug(\"Listening timeout - continuing\")\n        elif \"understand\" in error.lower():\n            response = self.language_manager.get_translation(\n                \"speech_not_clear\", \"voice_prompts\"\n            )\n            self._speak_response(response, self.language_manager.current_language)\n        else:\n            logger.warning(f\"Listening error: {error}\")\n    \n    def _is_exit_command(self, text: str) -> bool:\n        \"\"\"Check if text contains exit command in any supported language\"\"\"\n        text_lower = text.lower()\n        \n        # English exit words\n        english_exits = ['quit', 'exit', 'goodbye', 'bye', 'stop', 'end']\n        \n        # Hindi exit words\n        hindi_exits = ['बंद', 'समाप्त', 'अलविदा', 'बाई', 'रुको', 'खत्म']\n        \n        # Bengali exit words\n        bengali_exits = ['বন্ধ', 'শেষ', 'বিদায়', 'বাই', 'থামো']\n        \n        # Add more language-specific exit words as needed\n        all_exits = english_exits + hindi_exits + bengali_exits\n        \n        return any(word in text_lower for word in all_exits)\n    \n    def _is_language_change_command(self, text: str) -> bool:\n        \"\"\"Check if text contains language change command\"\"\"\n        text_lower = text.lower()\n        \n        # English language change commands\n        english_commands = ['change language', 'switch language', 'language']\n        \n        # Hindi language change commands\n        hindi_commands = ['भाषा बदलें', 'भाषा बदलो', 'भाषा']\n        \n        # Bengali language change commands\n        bengali_commands = ['ভাষা পরিবর্তন', 'ভাষা বদলাও', 'ভাষা']\n        \n        all_commands = english_commands + hindi_commands + bengali_commands\n        \n        return any(command in text_lower for command in all_commands)\n    \n    def _handle_language_change_command(self, text: str):\n        \"\"\"Handle language change command\"\"\"\n        # For now, cycle through supported languages\n        # In a more sophisticated implementation, parse the specific language requested\n        \n        supported_languages = self.language_manager.get_supported_languages(voice_only=True)\n        current_index = supported_languages.index(self.language_manager.current_language)\n        next_index = (current_index + 1) % len(supported_languages)\n        next_language = supported_languages[next_index]\n        \n        self.change_language(next_language.code)\n    \n    def _get_language_specific_system_prompt(self, language: SupportedLanguage) -> str:\n        \"\"\"Get system prompt tailored for specific language\"\"\"\n        base_prompt = f\"\"\"You are {self.settings.assistant_name}, a helpful voice assistant for NPCL (Noida Power Corporation Limited).\n\nYou are currently communicating in {language.english_name} ({language.native_name}).\n\nYour role:\n- Help customers with power connection inquiries\n- Handle complaint registration and status updates\n- Provide professional customer service in {language.english_name}\n- Use appropriate cultural context for {language.english_name} speakers\n\nCommunication guidelines:\n- Respond in {language.english_name} only\n- Keep responses concise (1-3 sentences) for voice conversation\n- Be respectful and professional\n- Use appropriate honorifics and cultural expressions\n- Provide helpful information about NPCL services\n\nNPCL serves: Noida, Greater Noida, Ghaziabad, Faridabad, and Gurugram.\n\"\"\"\n        \n        return base_prompt\n    \n    def _update_conversation_context(self, language: SupportedLanguage, user_input: str, response: str):\n        \"\"\"Update conversation context for the language\"\"\"\n        if language.code not in self.conversation_contexts:\n            self.conversation_contexts[language.code] = []\n        \n        self.conversation_contexts[language.code].append({\n            \"user\": user_input,\n            \"assistant\": response,\n            \"timestamp\": time.time()\n        })\n        \n        # Keep only last 10 exchanges per language\n        if len(self.conversation_contexts[language.code]) > 10:\n            self.conversation_contexts[language.code] = self.conversation_contexts[language.code][-10:]\n    \n    def _log_session_stats(self):\n        \"\"\"Log session statistics\"\"\"\n        if self.stats[\"start_time\"]:\n            duration = time.time() - self.stats[\"start_time\"]\n            logger.info(f\"Multilingual Session Statistics:\")\n            logger.info(f\"  Duration: {duration:.1f} seconds\")\n            logger.info(f\"  Conversations: {self.stats['conversations']}\")\n            logger.info(f\"  Language switches: {self.stats['language_switches']}\")\n            logger.info(f\"  Languages used: {', '.join(self.stats['languages_used'])}\")\n            logger.info(f\"  Successful recognitions: {self.stats['successful_recognitions']}\")\n            logger.info(f\"  Failed recognitions: {self.stats['failed_recognitions']}\")\n            logger.info(f\"  AI responses: {self.stats['ai_responses']}\")\n            logger.info(f\"  AI failures: {self.stats['ai_failures']}\")\n            logger.info(f\"  Total speech time: {self.stats['total_speech_time']:.1f}s\")\n            logger.info(f\"  Total processing time: {self.stats['total_processing_time']:.1f}s\")\n    \n    def get_stats(self) -> Dict[str, Any]:\n        \"\"\"Get current statistics\"\"\"\n        stats = self.stats.copy()\n        if stats[\"start_time\"]:\n            stats[\"duration\"] = time.time() - stats[\"start_time\"]\n        \n        # Add component statistics\n        stats[\"tts_stats\"] = self.tts.get_voice_statistics()\n        stats[\"stt_stats\"] = self.stt.get_recognition_statistics()\n        stats[\"language_info\"] = self.language_manager.get_language_info()\n        stats[\"supported_languages\"] = len(self.language_manager.get_supported_languages())\n        \n        return stats\n    \n    def get_supported_languages(self) -> List[Dict[str, Any]]:\n        \"\"\"Get list of supported languages\"\"\"\n        return [self.language_manager.get_language_info(lang) \n                for lang in self.language_manager.get_supported_languages()]\n    \n    def set_auto_language_detection(self, enabled: bool):\n        \"\"\"Enable or disable automatic language detection\"\"\"\n        self.auto_language_detection = enabled\n        logger.info(f\"Auto language detection {'enabled' if enabled else 'disabled'}\")\n    \n    def run_conversation_loop(self, auto_detect_language: bool = None):\n        \"\"\"Run the main conversation loop with language support\"\"\"\n        if not self.start():\n            return\n        \n        try:\n            logger.info(f\"Starting multilingual conversation loop in {self.language_manager.current_language.english_name}\")\n            \n            while self.is_running:\n                if not self.process_conversation_turn(auto_detect_language):\n                    break\n                    \n        except KeyboardInterrupt:\n            logger.info(\"Multilingual conversation loop interrupted\")\n        finally:\n            self.stop()